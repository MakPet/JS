alert('Hello, World!');

let currentUserName = prompt("Who is your name?", "Name");

if( currentUserName === null ) {
    currentUserName = "Неизвестный пользователь";
} else if(currentUserName == "") {
    currentUserName = "Неизвестный пользователь";
}

document.getElementById("name-user").innerHTML = currentUserName;

/*let currentUserName = prompt("Who is your name?", "Name");

let currentUserNameMessage = (currentUserName === null) ? "Неизвестный пользователь" :
    (currentUserName === "") ? "Неизвестный пользователь" : currentUserName;

document.getElementById("name-user").innerHTML = currentUserNameMessage;*/

/*
        Итак, инструкции — синтаксические конструкции и команды, которые выполняют действия.
        Отделять их нужно точкой с запятой.
        При переходе на новую строку их можно не ставить, но хорошим тоном считается их 
        ставить даже тогда. Обычно каждая инструкция на
        новой строке. 

        alert('Hi, mom');

    */

/*
    'use strict' для перехода в строгий режим или же современный, изменит поведение 
    некоторых функций. Рекомендуектся всегла начинать с
    этого свои скрипты. Некоторые функции языка автоматически включают строгий режим. 
*/

/*
    Итак, переменные должны хранить в себе какие-то значения. 

    Пример: 

    let Hello = 'Hi';
    alert('Hi');

    var — устаревший способ обновления переменной, подробднее о отличиях поговорим позже 

    const — переменная, значение которой не может изменяться, 
    верхний регистр если значение жесткое, известно заранее и не меняется и разный
    регистр если вычисляется. 

    Разрешенные символы: _ $ abcABC, некоторые слова зарезервированы

    Осмысленные имена переменных!

    let name = 'Джон';
    let admin = name;
    alert(admin);

    let currentUserName = 'Пользователь';
    let ourPlanetName = 'Earth';

*/

/*
    Итак, какие же типы данных у нас могут хранится в переменных?

    1. number

    let myNumber = 12345; Без кавычек

    Infinity - бесконечность, больше любого числа. А еще -Infinity, бесконечность, меньше любого числа.
    NaN - вычислительная ошибка.

    BigInt - числах не может быть больше 16 цифр, но если надо, то ставим b в конце, целыми числами, важно.

    2. строка string, заключена может быть в три типа кавычек.

    Двойные и одинарные — одно и то же. `` Обратные же интереснее. В них уже можно встраивать значения
    с помощью ${…}.

    Например

    let userName = `Имя`;
    alert(`Привет, ${userName}`);

    3. boolean, логические. Только true или false

    let iAmOldMan = false;

    let itIsTrue = 4 > 1;
    alert(itIsTrue);

    4. null

    Пусто, ничего, неизвестно.

    let name = null;
    alert(name);

    5. undefined

    Значение не было присвоено.

    let x;
    alert(x);

    6. object

    Хранит в себе более сложные объекты или же коллекции данных.

    symbol используют для создания уникальных id объектов.

    7. typeof возвращает тип аргумента

    Работает с кавычками и без.

    typeof Math; объект, который представляет математические операции и константы

    typeof null; объект, но это не верно

    typeof alert; функция, но в JS нет такого типа, они относятся к объектам. Но на практике это удобно.

*/

/*
    Иногда нужно преобразовать данные хотя чаще всего функции и операторы сами приводят значения к
    нужному типу.

    1. Строковое преобразование

    alert(awfa); string

    let myName = String(true);
    alert(typeof myName); тоже string

    2. Численное преобразование в матем функциях и выражениях, например, когда операция деления применяется
    не к числу. Но с + такое уже вроде не пройдет

    alert('6' + '2')

    let num = Number('123');
    alert(typeof num);

    Полезно, когда тебе с формы что-то приходит текстом

    Если строка не может быть приведена к числу, то нам вернут значение NaN(не удалось)

    let num = Number('undefined');
    alert(num); NaN

    let num = Number('null');
    alert(num); 0

    let num = Number('true/false');
    alert(num); 1/0

    let num = Number('');
    alert(num); Если пусто, то 0, пробелы игнор, если не цифры, то не удалось

    3. Логическое преобразование

    Может быть в логических операторах, но так же можно задать явно Boolean(true)

    Пустые значения: 0, NaN, null, undefined, становятся false.

    Но строка с пробелом у нас уже будет true, с нулем так же true, но строка. Если строка пустая,
    то false, если полная, то true.

    "" + 1 + 0 //1 Неправильно, олжно быть '10' "" считает за пустую сроку и тупо делает "1",
     а дальше дело техники

    "" - 1 + 0 //-1 Правильно. Отнимание арпиори с числами, поэтому "0" - 1, а дальше нормально
    true + false //1 Правильно. true это 1, false 0
    6 / "3" //2 Правильно. Деление априори к цифрам
    "2" * "3" //6 Правильно. Тоже, что и с делением
    4 + 5 + "px" //"9px" Правильно. Сначала сложение, поэтому 9, затем + строка
    "$" + 4 + 5 //$9 Неправильно. Сначала у нас строка складывается с числом, поэтому получается '$4', а
    заем уже и "$45"
    "4" - 2 //2 Правильно, строка 4 преобразовывается в число.
    "4px" - 2 // NaN Правильно, при отнимании строка преобразовывается читается как число, но там не
    только цифра
    7 / 0 //0   Неправильно. На ноль можно делить бесконечное кол-во раз. Будет infinity
    "  -9  " + 5 //-95 Неправильно. Добаляем строку, поэтому пробелы сохраняются   "-9  5"
    "  -9  " - 5 //-14 Правильно, математическое действие, пробелы у -9 игнорируются, получается -14
    null + 1 //1 Правильно, null после преобразования становится нулем
    undefined + 1 //NaN Правильно. undefined после преобразования в число выбьет NaN
    " \t \n" - 2 //NAn Неправильно \t \n какие-то спец символы. Поэтому будет 0 - 2 = -2. Эти символы
    обрежутся как пробелы и останется пустая строка
*/

/*
    Операторы в JS. Нам знакомы + - * и тд со школы. Что в них не входит?

    1. Термины

    ! Операнд, то к чему пременяется оператор. !

    !Унарный оператор пременяется только к одному операнду.!

    !Унарный минус!

    let x = 1;
    x= -x;
    alert(x); //-1

    !Бинарный оператор к двум операндам!

    let x = 1, y = 3;
    alert (y - x); // бинарный минус

    2. Бинарный + и строки и др

    !Если бинарный плюс применить к строкам, то они сложатся!

    let s = "моя" + "строка";
    alert(s); //моястрока

    Если хоть один из операндов с плюсом строка, то все к строке.
    Операция выполняется слева направо, это важно.

    alert(2 + 2 + "1"); //41, а не 221

    3. Унарный +

    У плюса есть и унарная форма, она не поменяет число, но преобразует операнд в число
    Например, с HTML формы пришли две строки, но нам нужно сделать их числами

    let weightApples = "1";
    let weightOranges = "2"'

    alert(+weightApples + +weightOranges); //3, а не 12

    4. Приоритеты

    У операторов есть приоритеты, но скобки всегда важнее приоритета. У унарных всегда приоритет
    выше, нежели у бинарных. Можно не запоминать, гуглить.

    Приоритет	Название	Обозначение
    …	            …	…
    16	        унарный плюс	+
    16	        унарный минус	-
    14	        умножение	    *
    14	        деление	/
    13	        сложение	    +
    13	        вычитание	    -
    …	        …	…
    3	        присваивание    =
    …	        …	…

    4. Присваивание

    У присваивания один из самых низких приоритетов, поэтому сначала выполнится другие операторы,
    а потом присваивание.

    Все операторы возвращают значения. x = value запишет value в x и вернет его.

    let a = 1;
    let b = 2;

    let c = 5 - (a = b + 1); // Сначала b + 1, затем a перезапишется и затем 5 - 3 = 2;

    alert(a); //3
    alert(c); //2

    5. Взятие остатка

    Еще один интересный оператор — взяnия остатка, записывается как % к ним никак не относится.

    alert( 5 % 2); //1

    6. Возведение в степень

    Оператор возведения в степень  **

    let a = 2;
    let b = 3;
    alert(a ** b); //8 , число a на само себя b раз

    Можно и с нецелыми числами

    alert( 16 ** (1/2)); // 4, потому что корень квадратный

    7. ИНКРЕМЕНТ/ДИКРЕМЕНТ

    Увеличивает или уменьшает переменную на еденицу, ++увеличивает --уменьшает

    ++ -- ОПЕРАТОРЫ

    let x = 1;
    ++x
    alert(x)// 2, как x = x + 1, только короче

    Можно применить только к переменной ++5 будет ошибкой.

    Есть две записи, перфиксная ++x, а так же постфиксная x++

    ПРЕФИКСНАЯ ФОРМА СНАЧАЛА УВЕЛИЧИВАЕТ, А ЗАТЕМ ПРИСВАИВАЕТ, ПОСТФИКСНАЯ ПРИСВАИВАЕТ, А ЗАТЕМ
    УВЕЛИЧИВАЕТ

    Можно увидеть, если нам только нужно вернуть значение.

    Префиксная вернет новое значение, а постфиксная старое.

    Например

    let x = 1;
    ++x;
    alert(x); //2

    let x = 1;
    let y = x++; Короче, сам x сначала вернет 1, а потом увеличится
    alert(x);

    Итоги: если результат оператора не используется, а нужно только увеличить переменную, то без
    разницы

    А если будем присваивать, выводить уже с оператором ++x, то разница тогда уже есть.

    ++x сразу вернет результат x++ Увеличит вернет старое, а затем увеличит

    Так же можно внутри выражений

    let x = 1;
    alert( 2 * ++x);//4

    let x = 1;
    alert( 2 * x++); //1
    alert(x); //2

    Но делать так не хорошо. Одна строка и несколько действий.

    let x = 1;
    alert( 2 * x); //1
    x++;


    8. Побитовые операторы работают с 32-разрядными целыми числами, или приводят к ним, на уровне их
    внутреннего двоичного представления.

    9. Если нужно применить оператор к переменной и сохранить результат в ней же.

    let x = 3;
    x = x + 2; // 5

    Но можно это заменить так

    let x = 3;
    x += 5;

    Приоритет такой же как и для обычного присваивания

    let n = 1;
    n += 3 + 1; Сначала 4, потом 1 + 4. А не 1+3, а затем непонято что.

    10. Оператор запятая

    Приоритет ниже присваивания, это очень важно. Позволяет вычислять несколько выражений и вернет
    последнее

    let x = ( 1 + 1, 3 + 2 );
    alert(x); //5

    Но из-за низкого приоритета без скобок будет так.

    let x = 1 + 1, 3 + 2;
    alert(x); //2, сначала будет lex x = 2, 5, затем в порядке очереди 2 присвоят, 5 откинут

    Нихера оно так не будет, ошибку выбьет.

    // три операции в одной строке
    for (a = 1, b = 3, c = a * b; a < 10; a++) {
        ...
    }

    Чет для фреймворка, но пока знать рано наверное.

    Задачки

    let a = 1, b = 1;

    let c = ++a;
    let d = b++;

    alert(a); //2
    alert(b); //2
    alert(c); //2
    alert(d); //1

    У преинкримента приоритет выше, поэтому a сначала увеличится и станет 2, а затем присвоится c, которая
    тоже станет 2. У постинкримента приоритет тоже выше, но сначала d присвоится b, а затем b увеличится
    будет 2.



    let a = 2;
    let x = 1 + (a *= 2);

    alert(a) // 4
    alert(x) // 5

    Сначала a = 4, затем x = 1 + 4


 */

/*
    Операторы сравнения.

    1. Известные из математики

    a > b; a < b; Больше меньше.
    a >= b; a <= b; Больше или равно, меньше или равно.
    a == b; Равенство, = присваивание
    a != b; Неравенство

    Возвращает логический тип сначения, true or flase.

    let x = 1 > 2;
    alert(x); //false
    Выше присваеваем результат переменной.

    2. Сравнить можно и сторки

    alert("А" > "Я");//false

    Сначала первая буква, потом вторая и пока не определит, верхний регистр проигрывает нижнему

    3. Сравнения разных типов. Строку попытается привести к числу и сравнит, логический тип к 1 или 0
    затем тоже сравнит.

    Может быть такое, что два значения будут равны, хотя одно из них true, а другое false

    let x = 0;
    alert( Boolean(x) ); //false

    let y = "0";
    alert( Boolean(x) ); //true

    alert( x == y ); //true

    Строка "0" не пуста, поэтому она true. Но равенство преведет строчку к числу, поэтому она станет
    false;
    false == false; //true

    4. Строгое преобрзование

    Обычное сравнение == все преобразует к числам
    alert( 0 == false ); // true, false станет числом и выпонится, тоже самое и с пустой строкой

    Тогда нам поможет строгое сравнение, оно обозначается === и не приводит результаты к числам.
    Такая же история и со строгим неравнством !== оно немедленно что-то сравнит не приводя к числам

    5. null и undefined

    При сторогом сравнении вернет false, т.к типы не равны

    А с обычным сравнением null == undefined и не равно чему либо другому.

    Поэтому alert( null == undefined ); //true, специальное правило, которое надо знать

    При использовании >, <, >=, <= null станет 0, undefined NaN

    Поэтому alert( null > 0 ); приведет null к 0 и вернет false
    Поэтому alert( null == 0 ); тоже false, т.к null НЕ РАВЕН ЧЕМУ ЛИБО ДРУГОМУ
    Поэтому alert( null >= 0); true, null преобразует 0, с точки зрения математики верно

    undefined нельзя с сравнить с чем-то кроме null!

    С осторожностью нужно сравнивать эти значения с чем либо, только если это не строгое неравенство

    6. Задачки
    5 > 4 //true
    "ананас" > "яблоко" //true, неправильно, если идет раньше в алфавите, то значит меньше
    "2" > "12" //false, но думал, что тут сравнение чисел, а тут сравнение строк, т.к обе строки, а не
    одна строка и число
    undefined == null //true undefined == только null и самому себе
    undefined === null //false Строгое сравнение
    null == "\n0\n" //false null == undefined и самому себе
    null === +"\n0\n" //false строгое сравнение разных типов

*/

/*  Фунции взаимодействия с бразузером

    1.
    alert(); Отобразит модальное окно (нельзя взаимсодействовать с интерфесом, пока не взаимодействуешь
    с окном), приостановит действие скриптов, пока не нажмут ОК

    2.
    prompt( "title", value);
    Принимает два аргумента. Отобразит модальное окно, title - заголовок, [] - заранее введенное значение

    Для explorer лучше установить value "", потому что тогда по умолчанию установится undefined

    3.
    confirm("Вопрос: ")
    Модальное окно с вопросом и двумя кнопками, ОК и ОТМЕНА. При выводе вернет true или false

*/

/* Условные операторы if и ?

    if() вычислит условие в скобках, если true, то выполнит блок кода, преобразует к логическому типу

    let currentYear = prompt("В каком году мы живем?","");
    if( currentYear == 2020 );
    alert("Верно!");

    Если нужено вывести больше двух функций, то юзаем фигурные скобки

    let currentYear = prompt("В каком году мы живем?","");
    if( currentYear == 2020 ) {
        alert("Верно!");
        alert("Молодец");
    }

    Так же есть необязательный блок else или иначе, выполнится если условие ложно

    let currentYear = prompt("В каком году мы живем?","");
    if( currentYear === 2020 ) {
        alert("Верно!");
        alert("Молодец");
    } else {
        alert("Неправильно!");
        alert("Ха-ха!")
    }

    2. Если нужно проверить несколько вариантов, то else if

    let currentYear = prompt("В каком году мы живем?","");
    if( currentYear < 2020 ) {
        alert("Мы живем слегка позже");
    } else if ( currentYear > 2020 ){
        alert("Мы живем слегка раньше");
    } else {
        alert("В яблочко!")
    }

    3. Условный оператор ?

    Иногда нам нужно задать значение переменной в зависимости от условия

    let currentAge = prompt("Сколько вам лет?","");
    let acceptAllowed;

    if( currentAge < 18 ) {
        acceptAllowed = "Вам рано это видеть";
    } else {
        acceptAllowed = "Добро пожаловать";
    }

    alert(acceptAllowed);

    Так называемый условный оператор позволяет сделать это короче, его еще называют, тернарный.
    Он единственный в своем роде и имеет три аргумента.

    let result = условие ? значение1 : значение2;

    Сначала вычислится условие, если оно истино, то переменной присвоится значение1, если нет,
    то значение2.

    let age = prompt("Сколько вам лет?","");
    let acceptAllowed = ( age < 18 ) ? "Вам рано это видеть" : "Добро пожаловать";
    alert(acceptAllowed);

    Технически скобки мы можем опустить, т.к. у ? низкий приоритет и он выполнится после сравнения.
    Но скобки сделают код более читабельным.

    Последовательность нескольких операторов ? позволит вернуть значение, которое зависит более чем от
    одного условия.

    let age = prompt("Сколько вам лет?", "");
    let message = (age < 5) ? "Привет малыш" :
        (age < 18) ? "Привет":
        (age < 100) ? "Здравствуйте" : "Очень необычный возраст";

    alert(message)

    Этот же вариант, но if, else if, else

    let age = prompt("Сколько вам лет?","");
    let message;

    if( age < 5 ) {
        message = "Привет малыш";
    } else if( age < 18 ) {
        message = "Привет";
    } else if( age < 100 ){
        message = "Здравствуйте";
    } else {
        message = "Какой необычный возраст"
    }

    alert(message);

    4. Замена тернарным оператором if

    let company = prompt("Сколько цветов во флаге Украины", "");

    (company == 2) ?
        alert("Верно") : alert("Неверно");

    Но делать нам так крайтне не рекомендуется.

    Задачки

    let officialNameJS = prompt("Какое «официальное» название JavaScript?", "");

    if( officialNameJS == "ECMAScript" ) {
        alert("Верно!");
    } else {
        alert("Не знаете? ECMAScript!");
    }

    let value = prompt("Положительное ваше число, отрицательное или же равно нулю?", "");

    if(value < 0 ){
        alert("Отрицательное");
    } else if(value > 0) {
        alert("Положительное");
    } else {
        alert("Ноль");
    }

    let result = (a + b < 4) ? "Мало" : "Много";


    let message;

    if (login == 'Сотрудник') {
        message = 'Привет';
    } else if (login == 'Директор') {
        message = 'Здравствуйте';
    } else if (login == '') {
        message = 'Нет логина';
    } else {
        message = '';
    }

    let login = prompt( "Ваш логин","" );

    let message = ( login == "Сотрудник" ) ? "Привет" :
    ( login == "Директор" ) ? "Здравствуйте" :
    ( login == "" ) ? "Нет логина" : ""

    Или же такой рабочий вариант



    let message = ( login == "Сотрудник" ) ? "Привет" :
        ( login == "Директор" ) ? "Здравствуйте" :
            ( login == "" ) ? "Нет логина" : "Значение неккорректно";

    alert(message);
 */

/*  Логические операторы || (ИЛИ), && (И), ! (НЕ)

    Могут применятся к любым типам, полученные значения могут иметь разный тип.

    1. || (ИЛИ) традиционно применяется для манипулирования будевыми значениями.
    Если какой-то тип true, но вернет true, в другом случае вернется false.

    Пример с булевыми значиениями

    alert( true || true ); // true
    alert( true || false ); //true
    alert( false || true ); // true
    alert( false || false ); // true

    Если значение не логического типа, то оно к нему приводится

    if( 1 || 0) {
        alert("Value")
    }; // Будет работать как if( true || false);

    Обычно используют в if для проверки истинности любого из заданых условий

    let hour = 9;

    if ( hour < 10 || hour > 18 ) {
        alert("Мы закрыты");
    }

    Мы можем передать и больше условий

    let hour = 9;
    let isWeekend = true;

    if ( hour < 10 || hour > 18 || isWeekend ) {
        alert("Мы закрыты");
    }

    Дополнительные возможности JS

    result = value1 || value2 || value3;

    Операнды вычисляются слева направо, каждый конвертируется в логическое значение. Если true,
    то останавливается и возвращается исходное значение этого операнда
    Если все false, то вернется последний из них.

    Мы можем получить первое истинное значение из списка переменных или или выражений.


    let currentUser = null;
    let deafultUser = "Vlad";

    let name = currentUser || deafultUser || "Не задано";
    alert( name );

    // Если бы и вторая переменная была бы false, то присвоило бы строку "Не задано"

    Сокращенные вычисления

    Операндами у нас могут быть как отдельные значения, т.к и произвольные выражения.
    Помним, слева направо. Второй операнд выполнится, если только первого недостаточно для вычисления
    всего выражения.

    let x;

    true || ( x = 1 );
    alert(x);

    //undefined, т.к x не вычислится, но в следующем случае.

    let x;

    false || ( x = 1 );
    alert(x);

    // Тут уже произойдет присваивание

    Этот вариант является аналогом if, если первое значение ложно, то вычислится второе.

    2. Оператор && (И)

    В традиционном програмировании вернет true если оба операнда истины, а иначе false;

    alert( true && true ); // true
    alert( true && false ); // false
    alert( false && true ); // false
    alert( false && false ); // false

    Пример с if

    let hour = 12;
    let minute = 30;

    if( hour == 12 &&  minute == 30) {
        alert("Сейчас на часах 12:30")
    }

    Допускается любое значение в качестве операнда

    if( 1 && 0 ) {
        alert("Не сработает, так как вернет false")
    }

    Находит первое ложное значение и возвращает его или последнее если ничего не найдено

    result = value1 && value2 && value3;

    Несколько значений подряд, пример;

    alert( 1 && 2 && null && 3); Вернет null
    alert( 1 && 2 && 3); Вернет 3

    Приоритет у && выше нежели у &&

    a && b || c && d

    Т.е сначала выполнятся И, а потом уже или.

    ( a && b ) || ( c && d )

    И этот оператор так же может заменить if

    let x = 1;

    ( x > 0 ) && alert("Первое значение будет true, так что вернется последнее");

    3. ! (НЕ)

    result = !value;

    ! сначала приведет операнд к логическому значению, а затем вернет его противоположное значение

    alert( !1 ) //false
    alert( !0 ) //true

    Двойное ! для преобразования к логическому типу. Первое конвертирует и вернет противоположное,
    второе коневертирует и снова вернет противоположное.

    alert( !!1 );
    alert( Boolean(1) ); // более подробный вариант

    Приоритет у ! наивысший среди всех логических операторов

    !!Задачи!!

    Что выведет?

    alert( null || 2 || undefined ); //2

    alert( alert(1) || 2 || alert(3) ); // alert у нас не возвращает значения, поэтому первый оператор
    || выполнит 1, получит undefined и пойдет дальше. А вот 2 уже будет true, его выведет во второй
    раз

    alert( 1 && null && 2 ); // null

    alert( alert(1) && alert(2) ); // Сначала 1 затем undefined, alert ничего не вернет или иначе говоря
    вернет undefined. Поэтому до второго оператора дело не дойдет

    alert( null || 2 && 3 || 4 ); // null это false, 2 && 3 вернет нам 3, т.к если превый операнд
    истинный, то возращается второй. Иными словаме, будет так

    alert( null || 3 || 4 );

    Значене age в диапазоне от 14 до 90

    let age = prompt("Введите цифру","");

    if( age >= 14 && age <= 90 ) {
        alert("Ваша цифра в диапазоне от 14 до 90.");
    } else {
        alert("Ваша цифра не диапазоне от 14 до 90.");
    }

    Значение НЕ в диапазоне от 14 до 90. Первый вариант без !, второй с ним.

    let age = prompt("Введите цифру","");

    if( age < 14 || age > 90 ) {
        alert("Ваша цифра не в диапазоне от 14 до 90.");
    }

    let age = prompt("Введите цифру","");

    if ( !(age >= 14) || !(age <= 90) ) {
        alert("Ваше значение не в диапазоне от 14 до 90.");
    }

    if (-1 || 0) alert( 'first' ); //выполнится, значением будет -1
    if (-1 && 0) alert( 'second' ); // невыполнится, значением будет false
    if (null || -1 && 1) alert( 'third' ); // сначала null || 1, остается просто 1, выполняется

    Напишите код, который будет спрашивать логин с помощью prompt.

    Если посетитель вводит «Админ», то prompt запрашивает пароль, если ничего не введено или
    нажата клавиша Esc – показать «Отменено», в противном случае отобразить «Я вас не знаю».

    Пароль проверять так:

    Если введён пароль «Я главный», то выводить «Здравствуйте!»,
    Иначе – «Неверный пароль»,
    При отмене – «Отменено».

    let login = prompt("Ваш логин?","");

    if( login == "Админ" ) {
        let password = prompt("Ваш пароль?", "");
            if(password == "Я главный") {
                alert("Здравствуйте");
            } else if( password === null ) {
                alert("Отменено");
            } else {
                alert("Неверный пароль");
            }
    } else if ( login === null || login == "" ) {
        alert("Отмена")
    } else {
        alert("Вы кто такие? Я вас не знаю.")
    }
*/

/*  Циклы while и for

    При написании скриптов иногда нужно сделать однотипное действие много раз.
    Например, вывести товары из списка один за другим или перебрать числа от 1 до 10, выплн одинк код.

    1. Цикл while

    while ( condition ) {
        //код так же называемый телом цикла
    }

    let i = 0;

    while (i < 3) { // выводит 0, затем 1, затем 2
        alert( i );
        i++;
    }

    Код выполняется пока условие истино. Т.е цикл сначала выведет 0, увеличит i, сравнит, выедет,
    увеличит и так дальше. Интерация - выполнение цикла

    Условием цикла может быть любое выражение или переменная, а не только сравнение.

    Например while (i < 3) более краткий вариант while ( i != 0 )

    let i = 5;

    while ( i ) {
        alert(i);
        i--;
    }

    Еще проверку условия можно разместить под телом цикла используя do ... while
    Пример

    let i = 5;

    do {
        alert(i);
        i--;
    } while (i)

    Цикл сначала выполнит тело, затем проверит условие и будет выполнять его снова и снова, пока оно не
    станет true. Так нужно делать, если мы хотим, чтобы тело вывелось один раз даже при ложном условии.

    2. Цикл for

    for (начало; условие ; шаг)  {

    }

    Цикл ниже выполнит alert(i) от 0 до 3, но не включая 3;

    for (let i = 0 ; i < 3 ; i++)  {
        alert(i);
    }

    Разбираем подробнее

    let i = 0, выполнится один раз, при ВХОДЕ в цикл
    i < 3 Условие проверяется каждый раз ПЕРЕД интерацией, если оно false, то цикл остановится
    Шаг i++ происходит ПОСЛЕ тела цикла на каждой интерации ПЕРЕД проверкой условия
    alert(i) выполняется снова и снова, пока условие истинно

    В нашем примере мы объявили переменную прямо в цикле, такие переменные называются существуют только
    внутри цикла. Так называемое встроенное объявление переменной

    for (let i = 0 ; i < 3 ; i++)  {
        alert(i);
    };

    alert(i); //ошибка, нет такой переменной

    Но нам ничего вместо объявления новой использовать уже существующую

    let i = 0

    for (i = 0 ; i < 3 ; i++)  {
        alert(i);
    };

    alert(i); переменная доступна, отобразит 3, т.к была объявлена снаружи цикла.

    3. Пропуск частей for

    3.1 Можем пропустить начало, уже есть объявленная переменная

    let i = 0

    for (; i < 3 ; i++)  {
        alert(i);
    };

    3.2 Можем убрать и шаг, но тогда у нас цикл станет аналогичен while (i < 3)

    let i = 0

    for (; i < 3 ;)  {
        alert(i++);
    };

    3.3 А можно вообще убрать все и цикл будет выполнятся вечно

    let i = 0

    for (;;)  {
        alert(i++);
    };

    Задачи по циклам

    1. Какое последнее значение выведет этот код? Почему?

    let i = 3;

    while (i) {
      alert( i-- );
    } //1

    Проверяем 3, это истино, выводим 3, уменьшаем.
    Проверяем 2, это истино, выводим 2, уменьшаем.
    Проверяем 1, это истино, выводим 1, уменьшаем.
    Проверяем 0, это не истино, ничего не выводим, конец.

    2. Для каждого цикла запишите, какие значения он выведет. Потом сравните с ответом.

    Оба цикла выводят alert с одинаковыми значениями или нет? (Нет.)

    2.1 Префиксный вариант ++i:

    let i = 0;
    while (++i < 5) alert( i );

    2.2 Постфиксный вариант i++

    let i = 0;
    while (i++ < 5) alert( i );

    Префиксный вариант, 0 увеличивает до 1, сравнивает 1 и возвращает 1
    1 увеличивает до 2, сравнивает 2 и возвращает 2
    2 увеличивает до 3, сравнивает 3 и возвращает 3
    3 увеличивает до 4, сравнивает 4 и возвращает 4
    4 увеличивает до 5, сравнивает 5, значение ложно, конец

    Постфиксный вариант

    Сравнивает 0, условие истино, но затем увеличивается и выводится 1
    Сравнивает 1, условие истино, но затем увеличивается и выводится 2
    Сравнивает 2, условие истино, но затем увеличивается и выводится 3
    Сравнивает 3, условие истино, но затем увеличивается и выводится 4
    Сравнивает 4, условие истино, но затем увеличивается и выводится 5
    Пять ложно, цикл прекращается

    3. Для каждого цикла запишите, какие значения он выведет. Потом сравните с ответом.

    Оба цикла выведут alert с одинаковыми значениями или нет? (Да)

    1. Постфиксная форма:

    for (let i = 0; i < 5; i++) alert( i );

    Выведет 0 и увеличит до 1
    Проверит, 1 меньше 5, выведет 1 и увеличит до 2
    Проверит, 2 меньше 5, выведет 2 и увеличит до 3
    Проверит, 3 меньше 5, выведет 3 и увеличит до 4
    Проверит, 4 меньше 5, выведет 4 и увеличит до 5
    Пять ложно, конец цикла

    Префиксная форма:

    for (let i = 0; i < 5; ++i) alert( i );

    Выведет 0 и увеличит до 1,
    Проверит, 1 меньше 5, выведет 1 и увеличит до 2
    Проверит, 2 меньше 5, выведет 2 и увеличит до 3
    Проверит, 3 меньше 5, выведет 3 и увеличит до 4
    Проверит, 4 меньше 5, выведет 4 и увеличит до 5

    4. При помощи цикла for выведите чётные числа от 2 до 10.

    for (let i = 2; i <= 10; ++i) {
        if (i % 2 == 1) continue;
        alert(i)
    }

    5. Перепишите код, заменив цикл for на while, без изменения поведения цикла.

    for (let i = 0; i < 3; i++) {
        alert( `number ${i}!` );
    }

    let i = 0;

    while (i < 3) {
        alert(`number ${i++}!`);
    }

    6. Напишите цикл, который предлагает prompt ввести число, большее 100.

    Если посетитель ввёл другое число – попросить ввести ещё раз, и так далее.

    Цикл должен спрашивать число пока либо посетитель не введёт число, большее 100, либо не нажмёт кнопку
    Отмена (ESC).

    Предполагается, что посетитель вводит только числа. Предусматривать обработку нечисловых строк
    в этой задаче необязательно.

    let i;

    do {
        i = prompt("Введите число, большее 100?", "");
    } while (i <= 100 && num);

    Для всех i от 1 до 10 {
        проверить, делится ли число i на какое-либо из чисел до него
        если делится, то это i не подходит, берём следующее
        если не делится, то i - простое число
    }
    Решение с использованием метки:

    let n = 10;

    nextPrime:
    for (let i = 2; i <= n; i++) { // Для всех i...

        for (let j = 2; j < i; j++) { // проверить, делится ли число..
        if (i % j == 0) continue nextPrime; // не подходит, берём следующее
    }
        alert( i ); // простое число
    }

    Первый цикл: 2 меньше n, второй цикл, j не меньше 2, 2 - простое число
    Первый цикл: 3 меньше n, второй цикл, j меньше 3, 3 с остатком поделится на 2, увелчиваем j до 3,
    j не меньше 3, 3 - простое число
    Первый цикл: 4 меньше n, второй цикл, j меньше 4, 4 без остатка поделится на 2, берем след число
    Первый цикл: 5 меньше n, второй цикл, j меньше 5, 5 с остатком поделится на 2, увеличиваем j,
    3 меньше 5, 5 с остатком поделится на 3, увеличиваем j, 4 меньше 5, 5 с остатком поделится на 4,
    увеличиваем j, j не меньше 5, 5 простое число
    Первый цикл: 6 меньше n, второй цикл, j меньше 6, 6 с остатком поделится на 2, увеличиваем j,
    3 меньше 6, 6 без остатка поделится на 3, дальше
    Первый цикл: 7 меньше n, второй цикл, j меньше 7, 7 с остатком поделится на 2, увеличиваем j,
    3 меньше 7, 7 с остатком поделится на 3, увеличиваем j, 4 меньше 7, 7 с остатком поделится на 4,
    увеличиваем j, j меньше 7, семь с остатком поделится на 5, увеличиваем j, j меньше 7, 7 с
    остатком поделится на 6, увеличиваем j, j не меньше 7, семь простое число

    Как-то так, мб есть ошибки. 


 */




